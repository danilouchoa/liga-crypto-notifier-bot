name: CI/CD - Liga Crypto Notifier Bot

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      short_sha: ${{ steps.short_sha.outputs.value }}
    steps:
      - name: Checkout do código
        uses: actions/checkout@v3

      - name: Definir hash curto
        id: short_sha
        run: echo "value=${GITHUB_SHA::6}" >> $GITHUB_OUTPUT

      - name: Cache dependências npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Instalar dependências
        run: npm install

  lint:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - uses: actions/checkout@v3
      - name: Restaurar cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - run: npm install
      - run: npm run lint

  prettier:
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v3
      - name: Restaurar cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - run: npm install
      - run: npx prettier . --check

  test:
    runs-on: ubuntu-latest
    needs: prettier
    steps:
      - uses: actions/checkout@v3
      - name: Restaurar cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - run: npm install
      - run: npm run test:coverage

  coverage:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v3
      - uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  audit:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v3
      - name: Restaurar cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - run: npm install
      - run: npm audit --audit-level=moderate

  semgrep:
    name: semgrep/ci
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: read
    env:
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
    container:
      image: semgrep/semgrep
    if: (github.actor != 'dependabot[bot]')
    steps:
      - uses: actions/checkout@v4
      - run: semgrep ci

  snyk:
    runs-on: ubuntu-latest
    needs: [semgrep, audit]
    if: ${{ success() }}
    steps:
      - uses: actions/checkout@v3
      - name: Restaurar cache npm
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-
      - run: npm install
      - uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: test

  deploy:
    runs-on: ubuntu-latest
    needs: [snyk, audit, coverage]
    if: ${{ success() }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      S3_BUCKET_NAME: automacao-liga-crypto
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      APP_NAME: automacao-liga-telegram-bot
      PLATFORM_ARN: arn:aws:elasticbeanstalk:us-east-1::platform/Node.js 20 running on 64bit Amazon Linux 2023/6.5.1
      VERSION_LABEL: ${{ github.sha }}-${{ github.run_number }}
    outputs:
      zap_target: ${{ steps.get-url.outputs.zap_target }}
      previous_env: ${{ steps.load-previous-env.outputs.previous_env }}
      current_env: ${{ steps.set-env-name.outputs.current_env }}
    steps:
      - uses: actions/checkout@v3

      - name: Definir nome do novo environment
        id: set-env-name
        run: |
          ENV_NAME=automacao-liga-env-${GITHUB_SHA::6}
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_ENV
          echo "current_env=$ENV_NAME" >> $GITHUB_OUTPUT

      - name: Configurar credenciais AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Carregar nome do último environment (via S3 ou fallback)
        id: load-previous-env
        run: |
          if aws s3 ls s3://${S3_BUCKET_NAME}/last-env-name.txt; then
            echo "Carregando último environment via S3..."
            aws s3 cp s3://${S3_BUCKET_NAME}/last-env-name.txt .
            PREVIOUS_ENV=$(cat last-env-name.txt)
          else
            echo "Nenhum arquivo no S3. Buscando environment ativo pelo Beanstalk..."
            PREVIOUS_ENV=$(aws elasticbeanstalk describe-environments \
              --application-name "${APP_NAME}" \
              --query "Environments[?Status=='Ready'].EnvironmentName | [0]" \
              --output text)
          fi

          echo "previous_env=$PREVIOUS_ENV" >> $GITHUB_OUTPUT

      - name: Instalar dependências (prod)
        run: npm ci --omit=dev

      - name: Zipar aplicação
        run: zip -r app.zip . -x '*.git*' 'node_modules/*' '*.zip'

      - name: Upload para S3
        run: aws s3 cp app.zip s3://$S3_BUCKET_NAME/automacao-${{ env.VERSION_LABEL }}.zip

      - name: Criar app Beanstalk se necessário
        run: |
          if [ "$(aws elasticbeanstalk describe-applications --query "Applications[?ApplicationName=='${APP_NAME}'] | length(@)")" -eq 0 ]; then
            aws elasticbeanstalk create-application --application-name ${APP_NAME}
          fi

      - name: Criar nova versão da aplicação
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name ${APP_NAME} \
            --version-label ${{ env.VERSION_LABEL }} \
            --source-bundle S3Bucket=$S3_BUCKET_NAME,S3Key=automacao-${{ env.VERSION_LABEL }}.zip

      - name: Criar novo environment (ou ignorar se já existir)
        run: |
          if [ "$(aws elasticbeanstalk describe-environments \
            --application-name \"${APP_NAME}\" \
            --query 'Environments[?EnvironmentName==`'"${ENV_NAME}"'`] | length(@)' \
            --output text)" -eq 0 ]; then
            aws elasticbeanstalk create-environment \
              --application-name ${APP_NAME} \
              --environment-name ${ENV_NAME} \
              --platform-arn "${PLATFORM_ARN}" \
              --version-label ${{ env.VERSION_LABEL }} \
              --option-settings \
                Namespace=aws:autoscaling:launchconfiguration,OptionName=IamInstanceProfile,Value=aws-elasticbeanstalk-ec2-role \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=TELEGRAM_BOT_TOKEN,Value=${{ secrets.TELEGRAM_BOT_TOKEN }} \
                Namespace=aws:elasticbeanstalk:application:environment,OptionName=TELEGRAM_CHAT_ID,Value=${{ secrets.TELEGRAM_CHAT_ID }} \
                Namespace=aws:elasticbeanstalk:environment:process:default,OptionName=HealthCheckPath,Value=/health
          else
            echo "Ambiente já existe."
          fi

      - name: Aguardar novo ambiente ficar pronto
        run: |
          for i in {1..20}; do
            STATUS=$(aws elasticbeanstalk describe-environments \
              --application-name "${APP_NAME}" \
              --environment-names "${ENV_NAME}" \
              --query "Environments[0].Status" \
              --output text 2>/dev/null)
            echo "Status atual: $STATUS"
            [ "$STATUS" == "Ready" ] && break
            sleep 30
          done

      - name: Atualizar environment com nova versão
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name ${ENV_NAME} \
            --version-label ${{ env.VERSION_LABEL }}

      - name: Salvar nome do novo environment
        run: |
          echo "$ENV_NAME" > last-env-name.txt
          aws s3 cp last-env-name.txt s3://${S3_BUCKET_NAME}/last-env-name.txt

      - name: Obter URL do ambiente
        id: get-url
        run: |
          URL=$(aws elasticbeanstalk describe-environments \
            --application-name "${APP_NAME}" \
            --environment-names "${ENV_NAME}" \
            --query "Environments[0].CNAME" \
            --output text)

          if [ "$URL" == "None" ]; then
            echo "Falha ao obter URL do ambiente Beanstalk"
            exit 1
          fi

          FULL_URL="https://$URL"
          echo "zap_target=$FULL_URL" >> $GITHUB_ENV
          echo "zap_target=$FULL_URL" >> $GITHUB_OUTPUT

  zap:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: ${{ success() }}
    env:
      ZAP_TARGET: ${{ needs.deploy.outputs.zap_target }}
      CURRENT_ENV: ${{ needs.deploy.outputs.current_env }}
    steps:
      - name: Validar zap_target
        run: |
          if [ -z "$ZAP_TARGET" ]; then
            echo "zap_target não definido. Abortando."
            exit 1
          fi

      - name: Mostrar URL do ZAP
        run: |
          echo "Escaneando: $ZAP_TARGET"

      - name: ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.14.0
        with:
          target: ${{ env.ZAP_TARGET }}
          fail_action: false

      - name: Deletar environments antigos (exceto o atual)
        run: |
          echo "Environment atual: $CURRENT_ENV"

          ENVIRONMENTS=$(aws elasticbeanstalk describe-environments \
            --application-name "automacao-liga-telegram-bot" \
            --query "Environments[?Status=='Ready'].EnvironmentName" \
            --output text)

          for ENV in $ENVIRONMENTS; do
            if [ "$ENV" != "$CURRENT_ENV" ]; then
              echo "Deletando environment antigo: $ENV"
              aws elasticbeanstalk terminate-environment \
                --environment-name "$ENV" \
                --terminate-resources
            else
              echo "Mantendo environment atual: $ENV"
            fi
          done
